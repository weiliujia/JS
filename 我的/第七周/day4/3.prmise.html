<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script src="jquery-1.11.3.js"></script>
<script>
    /*
     *
     * promise是es6中提供的一个类，它是用来解决异步问题的
     * 每一个promise的实例，用来解决一个异步问题
     * promise pending fulfiled rejected
     * 准确的说一共有两个状态 一个是初始太 另一个是完成态【成功/失败】
     *
     *promise 这个类执行的话，里面穿的是一个回调函数，不传的话会报错
     * resolve=> 成功之后执行的方法
     * rejected=> 失败之后执行的方法
     *
     * 在Promise中默认会返回一个状态，只要又返回，就代表这个Promise模式执行结束蓝
     *
     * 而Promise本身属于同步执行，里面的异步代码会放到异步队列中
     *
     * Promise这个类执行结束后，就会默认返回一个promise实例，我们可以利用实例调用他上公共方法 （then/catch/finally）
     *
     * promises这个类本身也带有方法比如（all/race/resolve/rejected）
     *
     *
     *
     *
     *
     * */
    new Promise((resolve, rejected) => {
        setInterval(() => {
            resolve()
        }, 14)
    });
    //被动执行
    //第二个及第二个以后的成功太he失败态执行与否取决于上一个then方法返回的状态【默认都是成功，只要代码不会出现报错默认都是成功】
    //第二个then方法的参数1【成功太】中的参数是return是返回的值，参数2【失败太】中的参数是上一个then方法的报错信息

    //主动执行
    //如果我们想手动让第二个then方法执行成功太或者失败太，我们可以默认返回一个Promise实例，让resolve或者rejected
    //【注意】每一个then方法不管是成功状态还是失败状态，他都会返回一个实例


    /*
     *
     * then中的第二个失败太和catch方法都会执行promise当中的reject方法，
     * 只要有第二个方法不会执行catch
     *
     * catch方法：不仅可以接受reject失败太，还可以检测上一个then方法当中是否报错的代码
     *
     * 建议优化：一般情况下，我们最好用catch方法代替then当中的第二个失败的函数【能用catch不用rej执行】【也有写多了会乱的原因】
     *
     * promise的实例操作的时候，调用then、catch、finally他们属于一个整体，跟我们用的 try catch finally 相似
     *
     *
     * */

</script>