<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script src="js/es6module/a.js" type="module"></script>
<!--若想用es6的模块导入导出 需要 我们-->
<script>

    /*
     *
     *
     * 自定义模块的相对路径
     * 导入：let 变量 = require(自定义模块的相对路径)
     *
     * module.exports === export  ---> {}
     * 导出：module.exports.name = 'zf'；
     *      module.exports = {name:'zf'};
     *      以上两种方式的导出 结果是一样的
     *      exports = {name:'zf'} 这种写法是不起作用的
     *      module.exports 还支持直接用 值类型覆盖 --> module.exports = 123
     *
     *
     *  一个模块中 有 require module __dirname__filename exports 这些只有在node中执行时才是被定义过得变量，在浏览器中执行时 是没有这些变量
     * */




    /*
     * 模块的导入和导出 目前一共两种方式
     * 第一种 是node的盗取和导出
     * node导入 let 变量 = require(要导入模块的路径)
     * node 导出  module.exports 和 exports 这两种方式导出：第一种方式 支持地址覆盖 也支持 用值类型覆盖 第二种方式只能老实的用 大典方式
     * node 方式的导入和导出 只能在 node环境中执行，不能在浏览器环境中执行
     *
     * 第二种 es6 的模块导入和导出
     * 引入入口文件(a.js)需要在script 标签上加上type="module" 这个属性
     * es6 导入 有三种方式
     *  1. import {变量名} from './b.js';这是变量名 必须 跟导出属性名保持一致
     *  这种导入方式需要的 导出方式是 export {obj：obj}
     *
     *  2. import 自定义变量名 from './b.js';
     *  这种导入方式 需要的导出方式 是 export default obj（变量名）
     *
     *  3.import * as 自定义量名 from './b.js';
     *  这种导入方式是把b中的所有导出 都放到自定义变量名的对象中
     *  4. import 自定义变量名{obj,str} from './b.js';
     *  这种导入方式需要导出方式是 export default 变量名 + export {obj,str}
     *  以上es6 的导入导出 需要在浏览器环境才能又婞 不能在node环境中运行
     *
     *  node 的 module.export 导出 可以写多个嘛？ 可以 只不过只有最下边的起作用
     *  es6  的export 导出 可以写多个嘛？ 可以 都起作用
     *
     *
     * */
</script>