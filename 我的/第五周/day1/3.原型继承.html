<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
<script>
    /*
     *
     * 原型继承
     * 子类的公有继承父类私有+公有
     *
     *
     * */
    function Parent() {
        this.name = 'zf'
    }
    Parent.prototype.getX = function () {
        return this.name
    };
    function Child() {
        this.age = 8
    }
    Child.prototype.getY = function () {
        return this.age
    };
    //父类的私有+公有属性=>只有父类的实例才会拥有
    //子类的公有=>子类的原型属性=>子类的公有位置



    child.prototype = new Parent();
    Child.prototype.constructor=Child;



    /*
    * 通过这种方式，子类的实例就可以调用父类的私有属性和公有方法；
    * 注意：我们要给子类的原型上扩展公共方法，必须等到继承完之后，再给添加才生效
    * 弊端
    * 我们给父类的私有属性添加多少，子类的公有属性就会拥有多少，最好的方法是子类的私有拥有父类的私有，子类的公有拥有父类的公有，所以我们需要学习计生组合继承
    * */



</script>