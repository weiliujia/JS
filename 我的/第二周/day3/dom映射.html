<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div id="box">
    <ul>
    <li>3</li>
    <li>4</li>
    <li>1</li>
    <li>2</li>
</ul>
</div>

</body>
</html>
<script>
    /*
    *
    * arguments映射
    * dom映射
    * 在JS中通过DOM提供的方法获取到这个元素和页面结构存在着一一对应的关系就叫做dom映射
    *
    * */

   /* // arguments映射
    function fn(a,b) {
        console.log(arguments[0]);
        a=2;
        console.log(arguments[0]);
    }
    fn(1,2)*/
   var box = document.getElementById('box');
   var lis = box.getElementsByTagName('li');
    lis.sort(function (a,b) {
        return a.innerHTML - b.innerHTML
    });

    var flag = document.createDocumentFragment();
    for (var i = 0; i < lis.length; i++) {
       // box.appendChild(lis[i])  消耗性能
        flag.appendChild(lis[i])

    }
    console.log(flag);
    //sort


    /*
    * 回流和重绘
    * 回流；当dom结构中的元素位置发生变化，或者增加元素以及删除元素，浏览器有监听机制，当页面元素发生变化以后，他会重新计算结构的位置，并且进行渲染，回流消耗的内存大，一般我们尽量减少真是dom的操作【浏览器不断监听导致的】，繁殖内存消耗
    * 重绘:dom结构中的样式发生变化，比如【颜色、字体大小、背景】发生变化，浏览器监听到元素的样式改变，会进行重新渲染，重回内存消耗小
    * 注意：1。必须是元素的内置属性发生改变，浏览器才能监听到
    *      2.querySelectorAll这种方式获取到的元素集合你没有dom映射
    *      3.如果元素本身就有，不会发生增加，会进行替换
    * createDocumentFragment 文档碎片
    *将变化的元素暂时存放到文档碎片当中，最后再添加给真实  的元素，保证我们的内存消耗讲到最低
    * */
</script>